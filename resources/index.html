<!DOCTYPE html>
<html>

<head lang="en">
    <meta charset="UTF-8">
    <title>Tetris AI</title>
    <link href="style/main.css" rel="stylesheet" type="text/css">
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
</head>

<body>
    <div id="fb-root"></div>
    <div class="container">
        <h1 class="header">Tetris flOw</h1>
        <div class="game-container">
            <canvas width="200px" height="400px" id="grid-canvas" class="grid"></canvas>
            <div class="controls-container">
                <div id="score-container" class="score-container">0</div>
                <div id="next-container" class="next-container">
                    <canvas id="next-canvas" class="next-canvas" width="80px" height="80px"></canvas>
                </div>
                <a id="ai-button" class="start-ai-button">Run AI</a>
                <a id="reset-button" class="reset-button">Reset</a>
            </div>
            <div>
                <canvas id="myChart"></canvas>
            </div>
        </div>
        <hr>
    </div>


    <script src="js/polyfill.js"></script>
    <script src="js/neutralino.js"></script>
    <script src="js/app.js"></script>
    <script src="js/grid.js"></script>
    <script src="js/piece.js"></script>
    <script src="js/timer.js"></script>
    <script src="js/stopwatch.js"></script>
    <script src="js/game_manager.js"></script>
    <script src="js/random_piece_generator.js"></script>
    <script src="js/ai.js"></script>
    <script src="js/tuner.js"></script>
    <script>

const CHART_SIZE = 300;
const CHART_STEP = 10;

const chartCanvas = document.getElementById('myChart');
chartCanvas.width = 500;
chartCanvas.height = 500;

const flowLine = Array.from({ length: CHART_SIZE / CHART_STEP }, (_, i) => i * CHART_STEP);
const labels = Array.from({ length: CHART_SIZE / CHART_STEP }, (_, i) => i * CHART_STEP);
const data = {
    labels: labels,
    datasets: [{
        label: 'My First Dataset',
        data: [],
        borderColor: 'rgb(0, 0, 150)',
        pointRadius: 0,
        pointHitRadius: 0,
        borderWidth: 2

    }, {
        label: 'Flow',
        data: flowLine,
        borderColor: 'rgb(150, 255, 150, 0.4)',
        borderWidth: 50,
        pointRadius: 0,
        pointHitRadius: 0,
    }]
};

const chart = new Chart(chartCanvas, {
    type: 'line',
    data,
    options: {
        plugins: {
            legend: {
                display: false
            },
            title: {
                display: true,
                text: `COLUNAS: ${window.COLS}` 
            }
        },
        animation: {
            duration: 0
        },
        responsive: true,
        scales: {
            x: {
                min: 0,
                max: CHART_SIZE,
                ticks: {
                    stepSize: 50
                }
            },
            y: {
                min: 0,
                max: CHART_SIZE,
                ticks: {
                    stepSize: 50
                }
            },
        }
    }
});

function calculateScores(logs) {
    const scores = [];
    let score = 0;
    let lastHoles = 0;
    let lastHeight = 0;
    let lastBumpiness = 0;
    let lastLines = 0;
    for (let i = 0; i < CHART_SIZE; i++) {

        if (i >= logs.length) break;

        const { holes, lines, height, bumpiness } = logs[i];
        let linesDiff = lines - lastLines;
        let holesDiff = holes - lastHoles;
        let heightDiff = height - lastHeight;
        let bumpinessDiff = bumpiness - lastBumpiness;

        lastLines = lines;
        lastHoles = holes;
        lastHeight = height;
        lastBumpiness = bumpiness;

        const log = logs[i];
        score += holesDiff * 5;
        score += heightDiff * 5;
        score += bumpinessDiff * 5;

        score -= linesDiff * 5;

        if (i % CHART_STEP === 0) scores.push(score);
    }
    return scores;
}

        // ----------------------------------------

        const RUN_TESTS = true;
        const ALL_PIECES = ['O', 'J', 'L', 'Z', 'S', 'T', 'I'];

        window.COLS = 10;
        window.ROWS = 22;
        window.GAME_SPEED = RUN_TESTS ? 20 : 0.25;
        window.LEVEL = 1;
        window.MOVE_CHOICE = 0;

        const gridCanvas = document.getElementById('grid-canvas');
        let game = {};
        let gameID = 0;
        let gameEnd = false;

        let testIndex = 0;
        let levelLinesCount = 0;

        const TESTS = [];
        const DROP_LIMIT = CHART_SIZE;
        const colsToTest = [8, 8, 10, 12, 14];
        const RUNS_BY_CONFIG = 10;

        for (let i = 0; i < colsToTest.length; i++) {
            const cols = colsToTest[i];
            for (let j = 0; j < RUNS_BY_CONFIG; j++) {
                TESTS.push({ rows: 20, cols, pieces: ['O', 'J', 'L', 'Z', 'S', 'T', 'I'] })
            }
        }

        const onResetGame = () => {

            game.id = gameID++;

            gameEnd = false;

            game.cols = RUN_TESTS ? TESTS[testIndex].cols : 10;
            game.rows = RUN_TESTS ? TESTS[testIndex].rows : 20;
            game.pieces = RUN_TESTS ? TESTS[testIndex].pieces : ALL_PIECES;
            //game.rows = 20;
            //game.cols = 10;
            //game.pieces = ALL_PIECES;
            game.lines = 0;
            game.level = 1;
            game.drops = 0;
            game.logs = [];

            if (RUN_TESTS) {
                testIndex++;
                levelLinesCount = 0;
            }

            window.LEVEL = 1;
            window.COLS = game.cols;
            window.ROWS = game.rows + 2;
            window.POSSIBLE_PIECES = game.pieces.map(p => ALL_PIECES.indexOf(p));

            gridCanvas.width = window.COLS * 20;
            gridCanvas.height = (window.ROWS - 2) * 20;
        }

        let gameOverTimeout = null;

        const saveCanvasImage = async (name, canvas) => {
            return new Promise((res, rej) => {
                canvas.toBlob((blob) => {
                    const url = URL.createObjectURL(blob);
                    fetch(url)
                        .then(response => response.arrayBuffer())
                        .then(buffer => {
                            window.saveBinaryFile(name, buffer);
                            res();
                        })
                        .catch(rej)
                        .finally(() => URL.revokeObjectURL(url));
                }, 'image/png');
            });
        }

        const onGameOver = ({ resetFunction }) => {

            gameEnd = true;

            clearTimeout(gameOverTimeout);
            gameOverTimeout = setTimeout(async () => {
                const name = new Date().getTime();
                await window.saveFile(gameID + '.json', game);

                await saveCanvasImage(gameID + '.png', chartCanvas);

                if (gameID >= TESTS.length) {
                    console.log('DONE');
                    return;
                }
                
                resetFunction?.();
            }, 1000);
        }

        const onStartTurn = ({ stats }) => {
            if (gameEnd) return;
            game.logs.push(stats);

            chart.data.datasets[0].data = calculateScores(game.logs);
            chart.options.plugins.title.text = `Grid Cols: ${game.cols} - Lines: ${game.lines} - Drops: ${game.drops}`;
            chart.update();
        }

        const onLineClear = ({ amount, resetFunction }) => {
            game.drops++;
            game.lines += amount;
            levelLinesCount += amount;

            if (RUN_TESTS && levelLinesCount >= 10) {
                levelLinesCount -= 10;
                window.LEVEL++;
                if (window.LEVEL > 10) window.LEVEL = 10;
                game.level = window.LEVEL;
            }

            window.MOVE_CHOICE = 0;
            const rand = Math.random();
            const probability = [0, 0.2, 0.2, 0.3, 0.35, 0.4, 0.45, 0.5, 0.55, 0.6, 0.65];

            if (rand < probability[window.LEVEL] / 2)
                window.MOVE_CHOICE = 2;
            else if (rand < probability[window.LEVEL])
                window.MOVE_CHOICE = 1;
            
            if (RUN_TESTS && game.drops >= DROP_LIMIT) {
                onGameOver({ resetFunction });
            }
        }

        window.manager = new GameManager({
            onGameOver, onStartTurn, onLineClear
        });


    </script>
</body>

</html>